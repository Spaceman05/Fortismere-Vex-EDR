#pragma config(Motor,  port1,           claw2,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           armL1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armL2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armR1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armR2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wheelLF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wheelLB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           wheelRF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           wheelRB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw1,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define PI 3.14159265358979323846
#define DEG2RAD( x ) ( (float)( x ) * (float)( (float)( PI ) / 180.0 ) )
//#define DEG2RAD(x) x
#define RAD2DEG( x ) ( (float)( x ) * (float)( 180.0 / (float)( PI ) ) )

#define RADPI (180 / PI)
#define HALFPI (1/2) * PI)
#define THREEQUATERPI (1/3) * PI)
#define TWOPI TWOPI

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

int calcAngle2(int x, int y)
{
	float theta = atan(y / x) * (180 / PI);

	float psi = 90 - theta;

	if (psi < 0)
		psi += 360;

	return (int)psi;
}


/*int calcAngle(int x, int y)
{
	int theta = abs(atan(y / x) * (180 / PI));

	int outAngle = 0;

	if(sgn(x) == 1 && sgn(y) == 1) // top right quadrant
	{
		outAngle = 90 - theta;
	}
	else if(sgn(x) == 1 && sgn(y) == -1) //bottom right quadrant
	{
		outAngle = 180 - theta;
	}
  else if(sgn(x) == -1 && sgn(y) == -1) //bottom left quadrant
	{
		outAngle = 270 - theta;
	}
	else if(sgn(x) == -1 && sgn(y) == 1) //top left quadrant
	{
		outAngle = 360 - theta;
	}

	return outAngle;
}*/


void DriveTo(int direction, int speed, int *motors)
{
	//motorStruct motors;
	//Values of the motors to be returned L1 = 1, L2 = 2, R1 = 3, R2 = 4

	//Makes the posative at in range of 0-360
	while (direction >= TWOPI)
	{
		direction -= TWOPI;
	}
	//Motors
	//0-90
	if (0 <= direction && direction <= HALFPI)
	{
		motors[0] = HALFPI - (direction * 2);						//Pair 1
		motors[1] = HALFPI;															//Pair 2
	}
	//90-180
	else if (HALFPI < direction && direction <= PI)
	{
		motors[0] = - HALFPI;														//Pair 1
		motors[1] = HALFPI - ((direction - HALFPI) * 2);		//Pair 2
	}
	//180-270
	else if (PI < direction && direction <= THREEQUATERPI)
	{
		motors[0] = - HALFPI + ((direction - PI) * 2);	//Pair 1
		motors[1] = - HALFPI;														//Pair 2
	}
	//270-360
	else if (THREEQUATERPI < direction && direction <= TWOPI)
	{
		motors[0] = HALFPI;															//Pair 1
		motors[1] = -HALFPI+ ((direction - THREEQUATERPI * 2));	 	//Pair 2
	}

	motors[0] = (float)motors[0] * 80.8507110907;
	motors[1] = (float)motors[1] * 80.8507110907;

	//update motor pair 1
	motors[2] = -motors[1];

	//update motor pair 2
	motors[3] = -motors[0];
}

void DoMotor(int degrees, int speed)
{
	int motors[4];
	DriveTo(degrees, speed, motors);

	motor[wheelLF] = motors[0];
	motor[wheelLB] = motors[1];

	motor[wheelRF] = motors[2];
	motor[wheelRB] = motors[3];
}

task autonomous()
{
	// ..........................................................................
	// Insert user code here.
	// ..........................................................................

	// Remove this function call once you have "real" code.
	AutonomousCodePlaceholderForTesting();
}

task usercontrol()
{
	// User control code here, inside the loop
	while(true)
	{

		// Stuff for the arms
		if (vexRT[Btn5U])
		{
			motor[armL1] = 127;
			motor[armL2] = 127;
			motor[armR1] = 127;
			motor[armR2] = 127;
		}
		else if (vexRT[Btn5D])
		{
			motor[armL1] = -127;
			motor[armL2] = -127;
			motor[armR1] = -127;
			motor[armR2] = -127;
		}
		else
		{
			motor[armL1] = 0;
			motor[armL2] = 0;
			motor[armR1] = 0;
			motor[armR2] = 0;
		}

		// claws
		if(vexRT(Btn6D))
		{
			motor[claw1] = 127;
			motor[claw2] = 127;
		}
		else if(vexRT(Btn6U))
		{
			motor[claw1] = -127;
			motor[claw2] = -127;
		}
		else
		{
			motor[claw1] = 0;
			motor[claw2] = 0;
		}

		if(abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch4]) > 10)
		{
			int speed = sqrt(pow(vexRT[Ch3], 2) + pow(vexRT[Ch4], 2));
			DoMotor(calcAngle2(vexRT[Ch4], vexRT[Ch3]), speed);
		}

		//debug direction buttons
		else if(vexRT[Btn7U])
		{
			DoMotor(0, 127);
		}
		else if(vexRT[Btn7L])
		{
			DoMotor(90, 127);
		}
		else if(vexRT[Btn7D])
		{
			DoMotor(180, 127);
		}
		else if(vexRT[Btn7R])
		{
			DoMotor(270, 127);
		}
		else
		{
			motor[wheelLF] = 0;
			motor[wheelLB] = 0;

			motor[wheelRF] = 0;
			motor[wheelRB] = 0;
		}

		//emergency stop
		if(vexRT[Btn8R])
		{
			motor[wheelLF] = 0;
			motor[wheelLB] = 0;

			motor[wheelRF] = 0;
			motor[wheelRB] = 0;
		}
	}
}
