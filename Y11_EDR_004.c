#pragma config(Motor,  port1,           claw2,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           armL1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armL2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armR1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armR2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wheelLF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wheelLB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           wheelRF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           wheelRB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw1,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define PI 3.14159265358979323846
#define DEG2RAD( x ) ( (float)( x ) * (float)( (float)( PI ) / 180.0 ) )
//#define DEG2RAD(x) x
#define RAD2DEG( x ) ( (float)( x ) * (float)( 180.0 / (float)( PI ) ) )

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void DriveTo(int direction, int speed, int *motors)
{
	//motorStruct motors;
	//Values of the motors to be returned L1 = 1, L2 = 2, R1 = 3, R2 = 4
	//Makes the direction pos ABSALOUTE TYOU SILLYLL
	direction = abs(direction);
	//Makes the posative at in range of 0-360
	while (direction >= 360)
	{
		direction -= 360;
	}
	//Motors
	//0-90
	if (0 <= direction && direction <= 90)
	{
		motors[0] = 90 - (direction * 2);						//Pair 1
		motors[1] = 90;															//Pair 2
	}
	//90-180
	else if (90 < direction && direction <= 180)
	{
		motors[0] = -90;														//Pair 1
		motors[1] = 90 - ((direction - 90) * 2);		//Pair 2
	}
	//180-270
	else if (180 < direction && direction <= 270)
	{
		motors[0] = -90 + ((direction - 180) * 2);	//Pair 1
		motors[1] = -90;														//Pair 2
	}
	//270-360
	else if (270 < direction && direction <= 360)
	{
		motors[0] = 90;															//Pair 1
		motors[1] = -90+ ((direction - 270) * 2);	 	//Pair 2
	}

	motors[0] = (float)motors[0] * 1.41111111111;
	motors[1] = (float)motors[1] * 1.41111111111;

	//update motor pair 1
	motors[2] = -motors[1];

	//update motor pair 2
	motors[3] = -motors[0];
}

void DoMotor(int degrees, int speed)
{
	int motors[4];
	DriveTo(degrees, speed, motors);

	motor[wheelLF] = motors[0];
	motor[wheelLB] = motors[1];

	motor[wheelRF] = motors[2];
	motor[wheelRB] = motors[3];
}

task autonomous()
{
	// ..........................................................................
	// Insert user code here.
	// ..........................................................................

	// Remove this function call once you have "real" code.
	AutonomousCodePlaceholderForTesting();
}

task usercontrol()
{
	// User control code here, inside the loop
	while(true)
	{

		// Stuff for the arms
		if (vexRT[Btn5U])
		{
			motor[armL1] = 127;
			motor[armL2] = 127;
			motor[armR1] = 127;
			motor[armR2] = 127;
		}
		else if (vexRT[Btn5D])
		{
			motor[armL1] = -127;
			motor[armL2] = -127;
			motor[armR1] = -127;
			motor[armR2] = -127;
		}
		else
		{
			motor[armL1] = 0;
			motor[armL2] = 0;
			motor[armR1] = 0;
			motor[armR2] = 0;
		}

		// fwd + strafe


		if(vexRT(Btn6D))
		{
			motor[claw1] = 127;
			motor[claw2] = 127;
		}
		else if(vexRT(Btn6U))
		{
			motor[claw1] = -127;
			motor[claw2] = -127;
		}
		else
		{
			motor[claw1] = 0;
			motor[claw2] = 0;
		}

		// joystick doesnt sit at exact zero
		// it might be better to get the resting value onetime and use that instead?
		if(abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch4]) > 10)
		{
			int extraDegrees = 0;
			
			// get the sign bits for each value
			int sgn3 = sgn(vexRT[Ch3]); // y
			int sgn4 = sgn(vexRT[Ch4]); // x
			
			// check sign bits
			if(sgn4 == 1 && sgn3 == 1)
			{
				// top right - no extra degrees
			}
			else if(sgn4 == 1 && sgn3 == -1)
			{
				// bottom right - 90 extra degrees
				extraDegrees = 90;
			}
			else if(sgn4 == -1 && sgn3 == -1)
			{
				// bottom left - 180 extra degrees
				extraDegrees = 180;
			}
			else if(sgn4 == -1 && sgn3 == 1)
			{
				// top left - 270 extra degrees;
				extraDegrees = 270;
			}
			else if(abs(vexRT[Ch4] < 20) && sgn3 == -1)
			{
				// we dont have to handle the 0 case for straight up as it will be 0
				// straight down - extra angle should be 180
				extraDegrees = 180; 
			}
			else if(sgn4 == 1 && abs(vexRT[Ch4]) < 20)
			{
				// straight right - extra angle should be 90
				extraDegrees = 90;
			}
			else if(sgn4 == -1 && abs(vexRT[Ch4]) < 20)
			{
				// straight left - extra angle should be 270
				extraDegrees = 270;
			}
			
			// TODO: do we need to handle 0 case?
			
			int degrees = 0;

			if(abs(sgn3 + sgn4) != 2)
			{
				// regular case
				degrees = RAD2DEG(atan((vexRT[Ch4]) / (vexRT[Ch3])));
			}
			else
			{
				// handle this case for bottom right and top left where we need the other angle
				degrees = RAD2DEG(atan((vexRT[Ch3]) / (vexRT[Ch4])));
			}

			int speed = sqrt(pow(vexRT[Ch3], 2) + pow(vexRT[Ch4], 2));

			DoMotor(degrees, speed);
		}
		//End of problem
		else if(vexRT[Btn7U])
		{
			DoMotor(0, 127);
		}
		else if(vexRT[Btn7L])
		{
			DoMotor(90, 127);
		}
		else if(vexRT[Btn7D])
		{
			DoMotor(180, 127);
		}
		else if(vexRT[Btn7R])
		{
			DoMotor(270, 127);
		}
		else
		{
			motor[wheelLF] = 0;
			motor[wheelLB] = 0;

			motor[wheelRF] = 0;
			motor[wheelRB] = 0;
		}


		if(vexRT[Btn8R])
		{
			motor[wheelLF] = 0;
			motor[wheelLB] = 0;

			motor[wheelRF] = 0;
			motor[wheelRB] = 0;
		}
	}
}
